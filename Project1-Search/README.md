# Project 1: Search

## Question 1: For the depth first search algorithm (DFS) i implemented the frontier as a stack and the explored set as a set. I also used a dictionary to store for each state its parent and the action that needs to be done in order to get there from its parent. The algorithm is based on the pseudo-code you presented in the slides. The algorithm checks if the state has been visited before and then it decides whether or not to add it on the stack. When the current state is the goal state it constructs the path from the goal to start.

## Question 2: For the breadth first search algorithm (BFS) the two differences are that the frontier is now a queue and the algorithm checks if the child state is on the queue, by checking if it is on the dictionary, as well as in the explored set.

## Question 3: For the uniform cost search algorithm (UCS) the frontier is now a priority queue with priority being every state’s true cost from the start state. As the BFS it checks if the child state is on the explored set, then it proceeds by checking if it is on the queue. If the algorithm finds a registry on the dictionary then it checks if the new true cost is less than the one that’s already stored and decides accordingly

## Question 4: For the A* search algorithm (A*) is the same with the UCS but when it comes to check for the cost between the new previous and the new registry the new one is calculated with the addition of the heuristic cost of the child state + the true cost for that state.

## Question 5: 
* ## getStartState: I defined the startState as a tuple of the pacman’s startingPosition and the tuple of unvisited corners’ location.
* ## isGoalState: In this function the passing argument is a state consisting of the current pacman’s position and the tuple of unvisited corners. In order for a state to be the goal it needs to have zero unvisited corners.
* ## getSuccessorts: In the beginning i checked if the nextState hits a wall with the provided code. If not then i continued by checking if it is a corner and procceding by removing it in case it was, to make the new tuple of unvisited corners I splitted the given tuple in two sections, the first one was just before the current corner and the second one just after the current corner, otherwise it is making the successor and appending him to the list.

## Question 6: The idea behind the heuristic is that in order for the pacman to reach a goal state it must have visited all corners. So one thought is to calculate from the current state of the pacman the distance he has from all the corners he has not yet visited using the Manhattan distance. It would then select the corner with the shortest distance and repeat the previous distance calculation process. Each time it will add to the total sum the distance of the corner that is closest. The process will stop when the pacman visits all the corners. The Heuristic is admissible and consistent because we use Manhattan distance to calculate the distances which does not include walls in its calculation. Also, we know that the path we find each time is the optimal one so, we know that the heuristic will never overestimate the true distance.

## Question 7: The idea behind the heuristic is that in order for the pacman to reach the goal state it must have eaten all the food dots. So one thought is to calculate from the current state of the pacman the actual distance he has from all the dots with food he hasn’t eaten yet. The algorithm will then choose the food with the greatest distance as the value of the heuristic. The function is admissible and consistent because the pacman regardless of which food he chooses to eat first in order to reach the goal state he will have to eat all the foods so he will have to travel at least the distance to the food that is farthest from the state he is in at the moment. Therefore the heuristic will never overestimates the actual distance. In order for the heuristics not to take too long, I used the heuristicInfo set that you suggested in the slides in which I save a distance if it does not exist after I’m check for its existence.

## Question 8: As in the search problem the isGoalState is defined by whether or not the state has reached a goal position. In this case, we need to know if the coordinates matches a food. In AnyFoodSearchProblem this is achieved through the self.food variable which is represented as grid, for a given set of coordinates i.e (x,y) the self.food[x][y] returns T if the points matches a food or F if it is not. Those return actions can be defined as the isGoalState. Then findPathToClosestDot can be done calling the BFS function with argument the current problem because it will find the closet dot.