# Project 3: Logic

## Question 1: In this question for the three sentences we simply created each symbol with the function Expr(’symbol’). After that we applied the necessary operators and return the results. In findModelCheck we are creating a dummyClass with the lower-cased letters and then return a dictionary with the dummyClass we created to be the key and its value to be True. In the entails function we are using a theorem of of entailment and simply create the expression as we did before and apply the necessary operators. Last but not least, for the plTrueInverse function I used the pl true function which does exactly what the pronunciation asked me to do. In other words, the pl true function returns True if the propositional logic expression is true in the model and False if it is false. If the model does not specify the value for every proposition, this may return None, so we are passing, as arguments, the negation of the inverse statement, the assignments and return the result.

## Question 2: In question 2 i implemented all of functions. In the first one, atLeastOne I just returned the literals conjoined. In the function, I made a list where I stored the result of every two disjoined expressions. In the end, it returns the conjoin of that list. Last but not list, for the last function, exactlyOne it returns the result of conjoin the atLeastOne function with the atMostOne because if we have at least one and at most one it means we have exactly one. 

## Question 3: For the pacmanSuccessorAxiomSingle the pronuncation motivated us to look into SLAMSuccessorAxiomSingle where it was almost the same process but with more ≪parameters≫. In the end, the only thing we need to do is to return the if and only if of the expression of pacman at x,y and time now with the disjoin of the possible causes as the writer did in the SLAMSuccessorAxiomSingle but because we are not taking into consideration the failed move causes and auxilary expression definitions we don’t need to conjoin nothing. Moving to pacphysicsAxioms, following the algorithm that the pronuncation provided us with we looping through all coords and making a temporary list with the expressions ≪if a wall is at (x, y), then Pacman is not at (x, y) at t.≫. Then we conjoin the list and append it to the knowledge base. Then we are making one temporary list for the expression ≪Pacman is at exactly one of the non outer wall coords at timestep t.≫and we append the result from the function exactlyOne as we wered asked to. Furthermore, we are doing the same thing for the expression ≪Pacman takes exactly one of the four actions in DIRECTIONS at timestep t.≫. In the end, we are checking if there is a sensorModel we append its result to the final list of sentences and moving on to check if transitions with successorAxioms are valids and append them to the list as well. In the end, we return the list conjoined. For the checkLocationSatisfiability, we append in the knowledge base the pacphysicsAxioms at time 0 and 1. Then we append the pacman initial position and then its actions at time 0 and 1. In the end we are calling findModel to find us two models, the first one is for the expression ≪Pacman is at (x1, y1) at time t = 1 given x0 y0, action0, action1, proving that it’s possible that Pacman there. Notably, if model1 is False, we know Pacman is guaranteed to NOT be there.≫and the second one for the expresion ≪Pacman is NOT at (x1, y1) at time t = 1 given x0 y0, action0, action1, proving that it’s possible that Pacman is not there. Notably, if model2 is False, we know Pacman is guaranteed to be there.≫.

## Question 4: Following the pseudocode, in the beggining I append the pacman’s initial position at time 0. Then we are looping in range(50) printing the time step (I commented because it was annoying). Then we are making a temporary list where we take all pacman’s positions for every (x,y) in non wall coords and then append the result of the exactlyOne in the knowledge base as we were said to do. Then we do the same thing for the actions. Afterwards, we checking for the t not to be 0 because we can’t have successors and then call the pacmanSuccessorAxiomSingle for every (x,y) in the non wall coords. We append the result in the KB and we continue by making the model as in previous question. I also, want to point out that the goal is an expression of pacman str with x,y the ones in the beginning of the function at time t of the loop. In the end if the model if True we return the sequence of actions as were told to.


## Question 5: The pronuncation said that the question 4 is a fundemental part in question 5, so i added most of the question 4 with some adjustments. In the begging we also append the food expressions in the KB. In the loop we append the list with pacman’s position and the list with the actions and the successors as in the previous question. The only important differences are the goal formation which now is created by appending every negation of food location in a list and then conjoin it. The model is constructed the same way as before. The last thing i want to clarify is the food successors which is not explained very well in the pronuncation. For every (x,y) in food I’m creating the expressions Food[x,y] t, Food[x,y] t+1 and Pacman[x,y] t. Then I’m appending to the KB the sentences. The first sententance is ≪saying≫that if the food at t is true and pacman is there at time t then at t+1 if the food is false it means that the pacman ate it. The second sentence is ≪saying≫that if pacman is not at the location at time t then the food will be there at time t and at time t+1.

## Question 6: In the beggining we add to the KB the walls that are in the given list and those that are not. Afterwards for the given range I’m adding to the KB the pacphysics, action, and percept information as they were said to us. Also I add the possible pacman locations with updated KB which were also explained in the pronuncation. At last, I’m calling the moveToNextState and yield. 

## Question 7: As in some previous questions we append the initial pacman’s position to the KB and append whether or not there is a wall at that location. Next we are looping in a given range and append pacphysics, action, and percept information as in the previous question. We also, find provable wall locations with updated KB as were asked to. The algorithm to find those wall locations is given in the pronuncation. Last but not least, we are calling moveToNextState and yield.

## Question 8: This question is a combination of the two previous. We are appending the initial pacman’s position and an expresion which showing that the pacman cannot be at a wall. Afterwards, we are looping in a given range and we are constantly appending the pacphysics, action, and percept information to KB as well as the provable wall locations and the possible pacman locations. All of those were explained before and much more in the pronuncation that’s why Ι don’t think Ι need to explaine something else. In the end we call, as usually, the moveToNextState and yield. 